Kind origin type.
Kind loan type.
Kind point type.

/* input */
Type origin_live_on_entry origin -> point -> prop.
Type not_origin_live_on_entry origin -> point -> prop.
Type loan_issued_at origin -> loan -> point -> prop.
Type not_loan_issued_at origin -> loan -> point -> prop.
Type cfg_edge point -> point -> prop.
Type loan_invalidated_at loan -> point -> prop.
Type not_loan_killed_at loan -> point -> prop.
Type subset_base origin -> origin -> point -> prop.

Theorem OriginAxiom:
  forall Origin,
  forall Point,
  (origin_live_on_entry Origin Point) -> 
  (not_origin_live_on_entry Origin Point) -> false.
skip.

Theorem LoanAxiom:
  forall Origin,
  forall Point,
  forall Loan,
  (loan_issued_at Origin Loan Point) -> 
  (not_loan_issued_at Origin Loan Point) -> false.
skip.

Define dead_borrow_region_can_reach_root: origin -> point -> loan -> prop ,
       dead_borrow_region_can_reach_dead: origin -> point -> loan -> prop,
       dying_region_requires: origin -> point -> point -> loan -> prop ,
       live_to_dying_regions: origin -> origin -> point -> point -> prop ,
       dying_can_reach_origins: origin -> point -> point -> prop ,
       dying_can_reach: origin  -> origin -> point -> point -> prop,
       dying_can_reach_live: origin -> origin -> point -> point -> prop ,
       datafrog_opt_subset: origin -> origin -> point -> prop,
       datafrog_opt_origin_contain_loan_on_entry: origin -> loan -> point -> prop,
       datafrog_opt_loan_live_at: loan -> point -> prop,
       datafrog_opt_errors: loan -> point -> prop by

/* unfold 1 */
dead_borrow_region_can_reach_root Origin Point Loan :=
  loan_issued_at Origin  Loan  Point /\
  not_origin_live_on_entry Origin  Point ;

/* unfold 2 */
dead_borrow_region_can_reach_dead Origin Point Loan :=
  dead_borrow_region_can_reach_root Origin Point Loan;

/* unfold 3 */
dead_borrow_region_can_reach_dead  Origin2  Point  Loan  :=
  exists Origin1,
  dead_borrow_region_can_reach_dead Origin1  Point  Loan  /\
  datafrog_opt_subset Origin1  Origin2  Point  /\
  not_origin_live_on_entry Origin2  Point ;

/* unfold 4 */
dying_region_requires Origin  Point1  Point2  Loan  :=
  (datafrog_opt_origin_contain_loan_on_entry Origin  Loan  Point1  ) /\
  (not_loan_killed_at Loan  Point1  ) /\
  (cfg_edge Point1  Point2 ) /\
  (not_origin_live_on_entry Origin  Point2 );

/* unfold 5 */
live_to_dying_regions Origin1  Origin2  Point1  Point2  :=
  datafrog_opt_subset Origin1  Origin2  Point1  /\
  cfg_edge Point1  Point2  /\
  origin_live_on_entry Origin1  Point2  /\
  not_origin_live_on_entry Origin2  Point2 ;

/* unfold 6 */
dying_can_reach_origins Origin2  Point1  Point2  :=
  exists Origin1,
  live_to_dying_regions Origin1  Origin2  Point1  Point2 ;

/* unfold 7 */
dying_can_reach_origins Origin  Point1  Point2  :=
  exists Loan,
  dying_region_requires Origin  Point1  Point2  Loan ;

/* unfold 8 */
dying_can_reach Origin1  Origin2  Point1  Point2  :=
  dying_can_reach_origins Origin1  Point1  Point2 /\ 
  datafrog_opt_subset Origin1  Origin2  Point1 ;

/* unfold 9 */
dying_can_reach Origin1  Origin3  Point1  Point2  :=
  exists Origin2,
  dying_can_reach Origin1  Origin2  Point1  Point2   /\
  not_origin_live_on_entry Origin2  Point2 /\ 
  datafrog_opt_subset Origin2  Origin3  Point1 ;

/* unfold 10 */
dying_can_reach_live Origin1  Origin2  Point1  Point2  :=
  dying_can_reach Origin1  Origin2  Point1  Point2   /\
  origin_live_on_entry Origin2  Point2 ;

/* unfold 11 */
datafrog_opt_subset Origin1  Origin2  Point  :=
  subset_base Origin1  Origin2  Point ;

/* unfold 11 */
datafrog_opt_subset Origin1  Origin2  Point2  :=
  exists Point1,
  datafrog_opt_subset Origin1  Origin2  Point1   /\
  cfg_edge Point1  Point2  /\
  origin_live_on_entry Origin1  Point2   /\
  origin_live_on_entry Origin2  Point2 ;

/* unfold 12 */
datafrog_opt_subset Origin1  Origin3  Point2  :=
  exists Point1,
  exists Origin2,
  live_to_dying_regions Origin1  Origin2  Point1  Point2  /\
  dying_can_reach_live Origin2  Origin3  Point1  Point2 ;

/* unfold 13 */
datafrog_opt_origin_contain_loan_on_entry Origin  Loan  Point  :=
  loan_issued_at Origin  Loan  Point ;

/* unfold 14 */
datafrog_opt_origin_contain_loan_on_entry Origin  Loan  Point2  :=
  exists Point1,
  datafrog_opt_origin_contain_loan_on_entry Origin  Loan  Point1  /\
  (not_loan_killed_at Loan  Point1  ) /\
  cfg_edge Point1  Point2  /\
  origin_live_on_entry Origin  Point2 ;

/* unfold 15 */
datafrog_opt_origin_contain_loan_on_entry Origin2  Loan  Point2  :=
  exists Point1,
  exists Origin1,
  dying_region_requires Origin1  Point1  Point2  Loan  /\
  dying_can_reach_live Origin1  Origin2  Point1  Point2 ;

/* unfold 16 */
datafrog_opt_loan_live_at Loan  Point  :=
  exists Origin,
  datafrog_opt_origin_contain_loan_on_entry Origin  Loan  Point  /\
  origin_live_on_entry Origin  Point ;

/* unfold 17 */
datafrog_opt_loan_live_at Loan  Point  :=
  exists Origin1,
  exists Origin2,
  dead_borrow_region_can_reach_dead Origin1  Point  Loan  /\
  datafrog_opt_subset Origin1  Origin2  Point  /\
  origin_live_on_entry Origin2  Point ;

/* unfold 18 */
datafrog_opt_errors Loan  Point  :=
  loan_invalidated_at Loan  Point  /\
  datafrog_opt_loan_live_at Loan  Point .




Define  naive_subset: origin -> origin -> point -> prop,
        naive_origin_contains_loan_on_entry: origin -> loan -> point -> prop,
        naive_loan_live_at: loan -> point -> prop,
        naive_errors: loan -> point -> prop  by

/* 1 */
naive_subset Origin1  Origin2  Point  :=
  subset_base Origin1  Origin2  Point ;

/* 2 */
naive_subset Origin1  Origin2  Point2  :=
  exists Point1,
  naive_subset Origin1  Origin2  Point1 /\
  cfg_edge Point1  Point2 /\
  origin_live_on_entry Origin1  Point2 /\
  origin_live_on_entry Origin2  Point2 ;

/* 3 */
naive_subset Origin1  Origin3  Point  :=
  exists Origin2,
  naive_subset Origin1  Origin2  Point /\
  naive_subset Origin2  Origin3  Point ;

/* 4 */
naive_origin_contains_loan_on_entry Origin Loan Point  :=
  loan_issued_at Origin Loan Point ;

/* naive_origin_contains_loan_on_entry Origin Loan Point  := */
  /* cfg_node Point   */
  /* placeholder_Loan Origin  Loan ; */

/* 5 */
naive_origin_contains_loan_on_entry Origin2  Loan  Point  :=
  exists Origin1,
  naive_origin_contains_loan_on_entry Origin1  Loan  Point /\
  naive_subset Origin1  Origin2  Point ;

/* 6 */
naive_origin_contains_loan_on_entry Origin  Loan  Point2  :=
  exists Point1,
  (naive_origin_contains_loan_on_entry Origin  Loan  Point1) /\
  (not_loan_killed_at Loan  Point1 ) /\
  (cfg_edge Point1  Point2) /\
  (origin_live_on_entry Origin  Point2) ;

/* 7 */
naive_loan_live_at Loan  Point  :=
  exists Origin,
  naive_origin_contains_loan_on_entry Origin  Loan  Point /\
  origin_live_on_entry Origin  Point ;

/* 8 */
naive_errors Loan  Point  :=
  loan_invalidated_at Loan  Point /\
  naive_loan_live_at Loan  Point .


Theorem Axiom1: 
  forall Point1, 
  forall Point2,
  forall Origin1,
  forall Origin2,
  forall Loan, 
  (cfg_edge Point1 Point2) ->
  (datafrog_opt_origin_contain_loan_on_entry Origin1 Loan Point1) ->
  (datafrog_opt_origin_contain_loan_on_entry Origin2 Loan Point2) ->
  (forall Origin3, not_loan_issued_at Origin3 Loan Point2 ).
skip.

Theorem Lemma5:
  forall Loan,
  forall Origin1,
  forall Point,
  (forall Origin2, not_loan_issued_at Origin2 Loan Point ) ->
  (datafrog_opt_origin_contain_loan_on_entry Origin1 Loan Point) ->
  (origin_live_on_entry Origin1 Point) .
intros.
case H2.
apply H1 with Origin2 = Origin1.
apply LoanAxiom to H3 H4.
search.
case H4.
search.

Theorem Lemma4:
  forall Point1, 
  forall Point2,
  forall Origin1, 
  forall Origin2, 
  forall Loan, 
  (cfg_edge Point1 Point2) ->
  (datafrog_opt_origin_contain_loan_on_entry Origin1 Loan Point1) ->
  (datafrog_opt_origin_contain_loan_on_entry Origin2 Loan Point2) ->
  (origin_live_on_entry Origin2 Point2) .
intros.
apply Axiom1 to H1 H2 H3.
apply Lemma5 to H4 H3.
search.

Theorem Lemma24:
  ( 
    forall Point, 
    forall Origin1, 
    forall Origin2, 
    (datafrog_opt_subset Origin1 Origin2 Point) -> (naive_subset Origin1 Origin2 Point) 
  ) /\ (
    forall Point1, 
    forall Point2, 
    forall Origin1, 
    forall Origin2, 
    (dying_can_reach Origin1 Origin2 Point1 Point2 ) -> (naive_subset Origin1 Origin2 Point1)
  ).
induction on 1 1.
split.
intros.
case H1.
search.
apply IH to H2.
search.
case H3.
case H2.
apply IH to H6.
case H4.
apply IH to H12.
search.
apply IH1 to H11.
apply IH to H13.
search.

intros.
case H1.
apply IH to H3.
search.
apply IH1 to H2.
apply IH to H4.
search.


Theorem Lemma26:
  forall Origin,
  forall Loan,
  forall Point,
  ( datafrog_opt_origin_contain_loan_on_entry Origin Loan Point ) ->
  ( naive_origin_contains_loan_on_entry Origin Loan Point ).
induction on 1.
intros.
case H1.
search.
apply IH to H2.
search.
case H2.
apply IH to H4.
case H3.
case Lemma24.
apply H12 to H9.
search.


Theorem Lemma51:
  forall Origin,
  forall Loan,
  forall Point,
  dead_borrow_region_can_reach_dead Origin Point Loan ->
  naive_origin_contains_loan_on_entry Origin Loan Point.
induction on 1.
intros.
case H1.
case H2.
search.
apply IH to H2.
case Lemma24.
apply H6 to H3.
search.


Theorem DatafrogOpt2Naive:
  forall Loan,
  forall Point,
  datafrog_opt_errors Loan Point ->
  naive_errors Loan Point.
intros.
case H1.
case H3.
apply Lemma26 to H4.
search.
apply Lemma51 to H4.
case Lemma24.
apply H8 to H5.
search.








/*
Theorem Lemma18:
  forall Point, 
  forall Origin1, 
  forall Origin3, 
  (naive_subset Origin1 Origin3 Point) ->
  (
    (datafrog_opt_subset Origin1 Origin3 Point) \/
    (
     exists Origin2,
     datafrog_opt_subset Origin1 Origin2 Point /\
     naive_subset Origin2 Origin3 Point
    )
  ).

Theorem Lemma13:
  forall Point1, 
  forall Point2,
  forall Origin1, 
  forall Origin3, 
  forall Loan, 
  (datafrog_opt_origin_contain_loan_on_entry Origin1 Loan Point1) ->
  (cfg_edge Point1 Point2) ->
  (origin_live_on_entry Origin3 Point2 ) ->
  (naive_subset Origin1 Origin3 Point1) ->
  (not_loan_killed_at Loan Point1 ) ->
  (
    (datafrog_opt_origin_contain_loan_on_entry Origin1 Loan Point2) \/
    (datafrog_opt_origin_contain_loan_on_entry Origin3 Loan Point2) \/
    (
      exists Origin2,
      naive_subset Origin1 Origin2 Point1 /\
      naive_subset Origin2 Origin3 Point2 /\
      ( datafrog_opt_origin_contain_loan_on_entry Origin2 Loan Point2 ) 
    )
  ).
induction on 4.
intros. 
assert (origin_live_on_entry Origin1 Point2 ) \/ (not_origin_live_on_entry Origin1 Point2 ).
skip. /* TODO, can't deal with it */
case H6.
assert ( datafrog_opt_origin_contain_loan_on_entry Origin1 Loan Point2 ).
search.

case H4.
assert (datafrog_opt_subset Origin1 Origin3 Point1 ).
assert (dying_region_requires Origin1 Point1 Point2 Loan).
assert (dying_can_reach_origins Origin1 Point1 Point2 ).
assert (dying_can_reach Origin1 Origin3 Point1 Point2 ).
assert (dying_can_reach_live Origin1 Origin3 Point1 Point2 ).
assert (datafrog_opt_origin_contain_loan_on_entry Origin3 Loan Point2 ).
search.
*/
/*
Theorem Lemma2:
  forall Origin1,
  forall Loan,
  forall Point,
  (naive_origin_contains_loan_on_entry Origin1 Loan Point) ->
  (exists Origin2, datafrog_opt_origin_contain_loan_on_entry Origin2 Loan Point).
induction on 1.
intros.
case H1.
witness Origin1.
search.
apply IH to H2.
search.
apply IH to H2.
TODO one case unsolved
*/
/*
Theorem Lemma3:
  forall Origin1,
  forall Loan,
  forall Point,
  (naive_origin_contains_loan_on_entry Origin1 Loan Point ) ->
  (origin_live_on_entry Origin1 Point ) ->
  ( 
   exists Origin2,
   (datafrog_opt_origin_contain_loan_on_entry Origin2 Loan Point ) /\
   (origin_live_on_entry Origin2 Point)
  ).
/* intros. */
/* induction on 1. */
/* case H1. */
*/
